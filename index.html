<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#111827"/>
  <title>百家樂勝率計算器（PWA v4.4：可調路圖 + 和牌斜線 + 座標 + 橫向捲動）</title>
  <link rel="manifest" href="manifest_v44.webmanifest">
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --accent:#22c55e; --text:#e5e7eb; --danger:#ef4444; }
    *{ box-sizing:border-box; }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Noto Sans TC','PingFang TC','Hiragino Sans','Microsoft JhengHei',system-ui,sans-serif;}
    header{ padding:16px 16px 8px; text-align:center; }
    h1{ margin:0; font-size:20px; }
    .wrap{ max-width:980px; margin:0 auto; padding:10px; }
    .card{ background:var(--card); border:1px solid #1f2937; border-radius:12px; padding:14px; margin:10px; box-shadow:0 6px 24px rgba(0,0,0,.25); }
    label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
    input[type=text], input[type=number]{ width:100%; padding:12px; border-radius:10px; border:1px solid #334155; background:#0b1220; color:var(--text); outline:none;}
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row > *{ flex:1 1 180px; }
    button{ background:#1f2937; color:var(--text); border:1px solid #374151; padding:10px 12px; border-radius:10px; }
    button.primary{ background:var(--accent); border-color:#16a34a; color:#06220f; font-weight:600; }
    button.danger{ background:#311316; border-color:#7f1d1d; color:#fecaca; }
    small{ color:var(--muted); }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; }
    .stat{ flex:1 1 140px; background:#0b1220; border:1px solid #334155; border-radius:12px; padding:12px; text-align:center; }
    .stat h3{ margin:0; font-size:14px; color:var(--muted); }
    .stat .v{ font-size:24px; font-weight:700; margin-top:6px; }
    .chips{ margin-top:6px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; border:1px dashed #334155; border-radius:999px; padding:5px 8px; margin:4px 6px 0 0; }
    .x{ cursor:pointer; color:#fca5a5; font-weight:700; }
    .hint{ font-size:12px; color:var(--muted); margin-top:4px; }
    table{ width:100%; border-collapse:collapse; }
    th,td{ border-bottom:1px solid #1f2937; padding:8px; font-size:12px; text-align:center; }
    th{ color:#94a3b8; font-weight:600; }
    .scrollX{ overflow-x:auto; -webkit-overflow-scrolling: touch; border:1px solid #334155; border-radius:10px; background:#0b1220; }
    .road{ display:block; }
    .roadTitle{ display:flex; align-items:center; justify-content:space-between; margin-top:8px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header><h1>百家樂勝率計算器（v4.4：可調路圖 + 和牌斜線 + 座標 + 橫向捲動）</h1></header>
  <div class="wrap">
    <!-- 模擬與扣牌（保留必要介面） -->
    <div class="card">
      <div class="row">
        <div><label>副數 (預設 8)</label><input id="decks" type="number" min="1" max="16" value="8"></div>
        <div><label>模擬局數 Trials（建議 20000~60000）</label><input id="trials" type="number" min="1000" step="1000" value="30000"></div>
        <div><label>固定亂數種子（可空白）</label><input id="seed" type="number" placeholder="如 20250831"></div>
      </div>
      <div style="margin-top:10px;">
        <label>輸入已開牌（連續輸入即可；T/10 代表 10）</label>
        <input id="cards" type="text" placeholder="例如：AK103QQ7">
        <div class="row" style="margin-top:10px;">
          <button id="btnAdd">加入已開牌</button>
          <button id="btnCompute" class="primary">計算下局勝率</button>
          <button id="btnReset" class="danger">重設新牌靴</button>
        </div>
        <div class="row" style="margin-top:10px; align-items:center;">
          <div style="display:flex; align-items:center; gap:10px;">
            <input id="autoSave" type="checkbox" checked><label for="autoSave">自動儲存（localStorage）</label>
          </div>
          <button id="btnClearStore">清除儲存</button>
        </div>
        <div class="hint">Tips：每局把新開出的牌補進來再按「計算」。</div>
      </div>
    </div>

    <div class="card">
      <label>目前已扣除的牌</label>
      <div id="removed" class="chips"></div>
      <div class="row" style="margin-top:6px;">
        <small>總計已扣：<span id="removedCount">0</span> 張；剩餘：<span id="remainCount">0</span> 張</small>
      </div>
    </div>

    <div class="card">
      <label>結果</label>
      <div class="stats">
        <div class="stat"><h3>莊 (Banker)</h3><div id="bank" class="v">-</div></div>
        <div class="stat"><h3>閒 (Player)</h3><div id="play" class="v">-</div></div>
        <div class="stat"><h3>和 (Tie)</h3><div id="tie" class="v">-</div></div>
        <div class="stat"><h3>模擬局數</h3><div id="n" class="v">-</div></div>
      </div>
    </div>

    <!-- 路圖控制 -->
    <div class="card">
      <div class="row" style="align-items:center;">
        <div style="flex:1 1 auto;"><label>輸入實際開牌結果（生成路圖）</label></div>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="btnB">+ 莊</button>
          <button id="btnP">+ 閒</button>
          <button id="btnT">+ 和</button>
          <button id="btnUndo" class="danger">復原一步</button>
          <button id="btnClearRoads" class="danger">清空路圖</button>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div><label>行數 Rows（預設 6）</label><input id="rows" type="number" min="4" max="16" value="6"></div>
        <div><label>列數 Cols（預設 60）</label><input id="cols" type="number" min="20" max="200" value="60"></div>
        <div style="align-self:flex-end;"><button id="btnApplyGrid" class="primary">套用路圖格數</button></div>
      </div>

      <div class="roadTitle"><b>大路 (Big Road)</b><small id="gridInfo">6 行 × 60 列</small></div>
      <div class="scrollX"><canvas id="bigRoad" class="road"></canvas></div>

      <div class="roadTitle"><b>大眼仔 (Big Eye Boy)</b></div>
      <div class="scrollX"><canvas id="bigEye" class="road"></canvas></div>

      <div class="roadTitle"><b>小路 (Small Road)</b></div>
      <div class="scrollX"><canvas id="smallRoad" class="road"></canvas></div>

      <div class="roadTitle"><b>曱甴/蟑螂路 (Cockroach)</b></div>
      <div class="scrollX"><canvas id="cockroach" class="road"></canvas></div>

      <div class="hint">新增：① 可調整行列 ② 和牌以綠色斜線疊在大路圓點上 ③ 上方/左側顯示座標 ④ 支援橫向捲動。</div>
    </div>

    <!-- 歷史 + 趨勢 -->
    <div class="card">
      <div class="row" style="align-items:center;">
        <div style="flex:1 1 auto;"><label>歷史結果趨勢（每次按「計算下局勝率」記一筆）</label></div>
        <div style="display:flex; gap:8px;">
          <button id="btnExport">匯出 CSV</button>
          <button id="btnClearHist" class="danger">清空歷史</button>
        </div>
      </div>
      <canvas id="trend" style="width:100%;max-height:280px;"></canvas>
      <div style="overflow:auto; max-height:220px; margin-top:8px;">
        <table id="histTable">
          <thead><tr><th>#</th><th>時間</th><th>扣牌數</th><th>剩餘</th><th>Trials</th><th>Seed</th><th>閒%</th><th>莊%</th><th>和%</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card" style="text-align:center; color:#94a3b8;">可安裝為 App（PWA）。本工具僅供試算參考，賭博有風險，請量力而為。</div>
  </div>

  <script>
  // ===== Monte Carlo core (略同前) =====
  const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const VAL={'A':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':0,'J':0,'Q':0,'K':0};
  const VALUES_LIST=RANKS.map(r=>VAL[r]);
  function newShoe(numDecks=8){ const shoe={}; for(const r of RANKS) shoe[r]=4*numDecks; return shoe; }
  function shoeCounts(shoe){ return RANKS.map(r=>shoe[r]); }
  function parseCards(s){ s=(s||'').toUpperCase().replace(/,/g,'').replace(/\s+/g,''); const out=[];
    for(let i=0;i<s.length;i++){ const ch=s[i]; if(ch==='1'&&s[i+1]==='0'){out.push('10');i++;} else if(ch==='T'){out.push('10');} else if('A23456789JQK'.includes(ch)){out.push(ch);} } return out; }
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;};}
  function weightedDraw(counts,total,rand){let r=Math.floor(rand()*total)+1,c=0;for(let i=0;i<counts.length;i++){c+=counts[i];if(r<=c)return i;}return counts.length-1;}
  function simulateOneRound(counts,rand){const lc=counts.slice();let tot=lc.reduce((a,b)=>a+b,0);if(tot<4)return null;function draw(){const i=weightedDraw(lc,tot,rand);lc[i]-=1;tot-=1;return i;}
    const p=[draw(),draw()],b=[draw(),draw()]; let pt=(VALUES_LIST[p[0]]+VALUES_LIST[p[1]])%10,bt=(VALUES_LIST[b[0]]+VALUES_LIST[b[1]])%10;
    if(!(pt===8||pt===9||bt===8||bt===9)){let pv=null;if(pt<=5){p.push(draw());pv=VALUES_LIST[p[p.length-1]];pt=(pt+pv)%10;
      if(bt<=2){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===3&&pv!==8){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===4&&(2<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===5&&(4<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===6&&(6<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
    }else{ if(bt<=5){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;} } }
    if(pt>bt)return 0; if(bt>pt)return 1; return 2; }
  function monteCarlo(counts,trials=30000,seed=null){const wins=[0,0,0],rand=seed?mulberry32(Number(seed)>>>0):Math.random;let valid=0;
    for(let i=0;i<trials;i++){const r=simulateOneRound(counts,rand);if(r===null)break;wins[r]++;valid++;} if(valid===0)return{p:[0,0,0],n:0}; return{p:[wins[0]/valid,wins[1]/valid,wins[2]/valid],n:valid};}

  // ===== Auto Save / History =====
  const STORE_KEY='baccarat_pwa_state_v44';
  const HIST_KEY='baccarat_pwa_history_v44';
  const ROADS_KEY='baccarat_pwa_roads_v44';
  function saveState(){ if(!document.getElementById('autoSave').checked) return;
    const s={shoe,removed,prefs:{decks:Number(decksEl.value)||8,trials:Number(trialsEl.value)||30000,seed:seedEl.value||'',auto:document.getElementById('autoSave').checked}};
    try{localStorage.setItem(STORE_KEY,JSON.stringify(s));}catch(e){}}
  function loadState(){ try{const raw=localStorage.getItem(STORE_KEY); if(!raw)return false; const s=JSON.parse(raw);
    if(s&&s.shoe&&s.removed){ shoe=s.shoe; removed=s.removed; if(s.prefs){decksEl.value=s.prefs.decks??8;trialsEl.value=s.prefs.trials??30000;seedEl.value=s.prefs.seed??'';document.getElementById('autoSave').checked=!!s.prefs.auto;} refreshCounts(); return true; }}catch(e){} return false; }
  function clearState(){try{localStorage.removeItem(STORE_KEY);}catch(e){}}
  function loadHist(){try{const raw=localStorage.getItem(HIST_KEY);return raw?JSON.parse(raw):[];}catch(e){return[];}}
  function saveHist(h){try{localStorage.setItem(HIST_KEY,JSON.stringify(h));}catch(e){}}

  // ===== UI refs =====
  const decksEl=document.getElementById('decks'), trialsEl=document.getElementById('trials'), seedEl=document.getElementById('seed'), cardsEl=document.getElementById('cards');
  const removedDiv=document.getElementById('removed'), removedCount=document.getElementById('removedCount'), remainCount=document.getElementById('remainCount');
  const bankEl=document.getElementById('bank'), playEl=document.getElementById('play'), tieEl=document.getElementById('tie'), nEl=document.getElementById('n');
  const trendCanvas=document.getElementById('trend'); const histTableBody=document.querySelector('#histTable tbody');
  const bigRoadCanvas=document.getElementById('bigRoad'), bigEyeCanvas=document.getElementById('bigEye'), smallCanvas=document.getElementById('smallRoad'), cockroachCanvas=document.getElementById('cockroach');
  const rowsInput=document.getElementById('rows'), colsInput=document.getElementById('cols'); const gridInfo=document.getElementById('gridInfo');

  let shoe=newShoe(8), removed=[];
  if(!loadState()){ refreshCounts(); }

  // ===== History & Chart =====
  let history=loadHist(), chart=null;
  function redrawChart(){ const labels=history.map((h,i)=>(i+1).toString()); const p=history.map(h=>h.p), b=history.map(h=>h.b), t=history.map(h=>h.t);
    if(chart) chart.destroy(); chart=new Chart(trendCanvas.getContext('2d'),{type:'line',data:{labels,datasets:[{label:'閒(%)',data:p,tension:0.2},{label:'莊(%)',data:b,tension:0.2},{label:'和(%)',data:t,tension:0.2}]},
      options:{responsive:true,interaction:{mode:'index',intersect:false},plugins:{legend:{labels:{color:'#e5e7eb'}}},
        scales:{x:{ticks:{color:'#94a3b8'},grid:{color:'#1f2937'}},y:{ticks:{color:'#94a3b8',callback:v=>v+'%'},
        grid:{color:'#1f2937'},min:0,max:100}}});}
  function redrawTable(){ histTableBody.innerHTML=''; history.forEach((h,i)=>{ const tr=document.createElement('tr');
    tr.innerHTML=`<td>${i+1}</td><td>${h.time}</td><td>${h.rem}</td><td>${h.left}</td><td>${h.trials}</td><td>${h.seed??''}</td><td>${h.p.toFixed(2)}</td><td>${h.b.toFixed(2)}</td><td>${h.t.toFixed(2)}</td>`; histTableBody.appendChild(tr); }); }
  function pushHistory({p,b,t,n}){ const now=new Date(); const rec={time:now.toLocaleTimeString(),rem:removed.length,left:Object.values(shoe).reduce((a,b)=>a+b,0),trials:Number(trialsEl.value)||30000,seed:seedEl.value||'',p:p*100,b:b*100,t:t*100,n}; history.push(rec); if(history.length>100)history.shift(); saveHist(history); redrawTable(); redrawChart(); }

  // ===== Roads =====
  let outcomes=[]; // sequence with 'B','P','T'
  try{const raw=localStorage.getItem(ROADS_KEY); if(raw) outcomes=JSON.parse(raw);}catch(e){}
  function saveRoads(){try{localStorage.setItem(ROADS_KEY,JSON.stringify(outcomes));}catch(e){}}

  function buildBigRoad(seq, rows, cols){
    const grid=[...Array(rows)].map(()=>Array(cols).fill(null));
    const ties=[...Array(rows)].map(()=>Array(cols).fill(0)); // tie counts per cell
    const pure=[]; // positions mapping for B/P only
    let last=null; let col=0, row=0; let colHeights=Array(cols).fill(0);
    function place(bp){
      if(last===null){ col=0; row=0; }
      else if(bp===last){
        if(row<rows-1 && grid[row+1][col]==null){ row++; }
        else{ col++; row=colHeights[col]||0; }
      }else{ col++; row=0; }
      if(col>=cols) return false;
      grid[row][col]=bp; colHeights[col]=Math.max(colHeights[col],row+1); last=bp; pure.push({c:col,r:row}); return true;
    }
    // iterate original seq keeping ties on last cell
    let lastPos=null;
    for(const x of seq){
      if(x==='T'){ if(lastPos){ ties[lastPos.r][lastPos.c]=(ties[lastPos.r][lastPos.c]||0)+1; } continue; }
      const ok=place(x); if(!ok) break; lastPos={c:col,r:row};
    }
    return {grid,ties,colHeights,rows,cols};
  }

  function deriveRoad(big, offset){
    const rows=big.rows, cols=big.cols;
    const marks=[...Array(rows)].map(()=>Array(cols).fill(null));
    function colLen(c){ let n=0; for(let r=0;r<rows;r++){ if(big.grid[r][c]!=null) n=r+1; } return n; }
    function exists(c,r){ return c>=0 && c<cols && r>=0 && r<rows && big.grid[r][c]!=null; }
    for(let c=0;c<cols;c++){
      for(let r=0;r<rows;r++){
        if(big.grid[r][c]==null) continue;
        const cA=c-1-offset, cB=c-2-offset;
        let color=null;
        if(r===0){
          if(cB>=0){ color = (colLen(cA)===colLen(cB)) ? 'R' : 'B'; }
        }else{
          if(cA>=0){ color = exists(cA, r-1) ? 'R' : 'B'; }
        }
        if(color){
          let rr=0; while(rr<rows && marks[rr][c]!=null) rr++;
          if(rr<rows) marks[rr][c]=color;
        }
      }
    }
    return {marks,rows,cols};
  }

  function drawRoad(canvas, cells, mode, tiesGrid=null, rows=6, cols=60){
    // mode: 'BP' big road, 'RB' derived
    const cellSize=18; // px per cell
    const W=canvas.width=cols*cellSize + 30; // extra for y-axis labels
    const H=canvas.height=rows*cellSize + 20; // extra for x-axis labels
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,W,H);
    // grid & coordinates
    ctx.strokeStyle='#1f2937'; ctx.lineWidth=1; ctx.fillStyle='#94a3b8'; ctx.font='10px system-ui';
    // y labels
    for(let r=0;r<=rows;r++){
      const y= r*cellSize + 0.5;
      ctx.beginPath(); ctx.moveTo(30,y); ctx.lineTo(W,y); ctx.stroke();
      if(r<rows){ ctx.fillText(String(r+1), 2, y + cellSize*0.65); }
    }
    // x labels
    for(let c=0;c<=cols;c++){
      const x= 30 + c*cellSize + 0.5;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H-20); ctx.stroke();
      if(c<cols){ ctx.fillText(String(c+1), x+3, H-6); }
    }
    // draw cells
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const v=cells[r][c]; if(!v) continue;
        const cx = 30 + c*cellSize + cellSize/2;
        const cy = r*cellSize + cellSize/2;
        const rad = cellSize*0.38;
        if(mode==='BP'){
          ctx.fillStyle = (v==='B') ? '#ef4444' : '#3b82f6';
          ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill();
          // draw tie slashes if any
          if(tiesGrid){
            const t = tiesGrid[r][c]||0;
            if(t>0){
              ctx.strokeStyle='#22c55e'; ctx.lineWidth=2;
              // draw one or multiple short slashes
              for(let k=0;k<Math.min(3,t);k++){
                const off=-rad*0.6 + k*(rad*0.6);
                ctx.beginPath(); ctx.moveTo(cx-rad*0.6, cy+off);
                ctx.lineTo(cx+rad*0.6, cy-rad*0.6+off);
                ctx.stroke();
              }
              if(t>3){ ctx.fillStyle='#22c55e'; ctx.font='10px system-ui'; ctx.fillText('x'+t, cx-rad, cy+rad+8); }
            }
          }
        }else{
          ctx.fillStyle = (v==='R') ? '#ef4444' : '#3b82f6';
          ctx.beginPath(); ctx.arc(cx,cy,rad*0.7,0,Math.PI*2); ctx.fill();
        }
      }
    }
  }

  function rebuildRoads(){
    const rows = Math.max(4, Math.min(16, Number(rowsInput.value)||6));
    const cols = Math.max(20, Math.min(200, Number(colsInput.value)||60));
    gridInfo.textContent = rows + ' 行 × ' + cols + ' 列';
    const big = buildBigRoad(outcomes, rows, cols);
    drawRoad(bigRoadCanvas, big.grid, 'BP', big.ties, rows, cols);
    const bigEye = deriveRoad(big, 1);
    const small  = deriveRoad(big, 2);
    const cock   = deriveRoad(big, 3);
    drawRoad(bigEyeCanvas, bigEye.marks, 'RB', null, rows, cols);
    drawRoad(smallCanvas,  small.marks,  'RB', null, rows, cols);
    drawRoad(cockroachCanvas, cock.marks,'RB', null, rows, cols);
  }

  function addOutcome(x){ if(!['B','P','T'].includes(x)) return; outcomes.push(x); saveRoads(); rebuildRoads(); }
  function undoOutcome(){ outcomes.pop(); saveRoads(); rebuildRoads(); }
  function clearOutcomes(){ outcomes=[]; saveRoads(); rebuildRoads(); }

  // ===== Counts & actions =====
  function refreshCounts(){ const total=Object.values(shoe).reduce((a,b)=>a+b,0); removedCount.textContent=removed.length; remainCount.textContent=total;
    removedDiv.innerHTML=''; removed.forEach((c,idx)=>{ const chip=document.createElement('span'); chip.className='chip';
      chip.innerHTML='<b>'+c+'</b> <span class="x" title="移除此扣牌">×</span>'; chip.querySelector('.x').onclick=()=>{ shoe[c]=(shoe[c]||0)+1; removed.splice(idx,1); refreshCounts(); saveState(); }; removedDiv.appendChild(chip); }); }

  function addCards(text){ const arr=parseCards(text); if(arr.length===0){ alert('請輸入如 AK103'); return; }
    for(const c of arr){ if(RANKS.indexOf(c)===-1){ alert('無法識別的牌面：'+c); return; } if(!shoe[c]||shoe[c]<=0){ alert('牌庫中沒有足夠的 '+c+' 可扣除'); return; } }
    arr.forEach(c=>{ shoe[c]-=1; removed.push(c); }); cardsEl.value=''; refreshCounts(); saveState(); }

  document.getElementById('btnAdd').onclick=()=> addCards(cardsEl.value);
  cardsEl.addEventListener('keydown', e=>{ if(e.key==='Enter') addCards(cardsEl.value); });
  document.getElementById('btnReset').onclick=()=>{ const d=Math.max(1,Math.min(16, Number(decksEl.value)||8)); shoe=newShoe(d); removed=[]; bankEl.textContent=playEl.textContent=tieEl.textContent=nEl.textContent='-'; refreshCounts(); saveState(); };
  document.getElementById('btnCompute').onclick=()=>{ const counts=shoeCounts(shoe); const t=Math.max(1000, Number(trialsEl.value)||30000); const seed=seedEl.value? Number(seedEl.value): null;
    const r=monteCarlo(counts,t,seed); playEl.textContent=(r.p[0]*100).toFixed(2)+'%'; bankEl.textContent=(r.p[1]*100).toFixed(2)+'%'; tieEl.textContent=(r.p[2]*100).toFixed(2)+'%'; nEl.textContent=r.n.toLocaleString();
    pushHistory({p:r.p[0], b:r.p[1], t:r.p[2], n:r.n}); saveState(); };
  document.getElementById('autoSave').addEventListener('change', ()=>{ if(document.getElementById('autoSave').checked) saveState(); });
  document.getElementById('btnClearStore').onclick=()=>{ if(confirm('確定要清除儲存？')){ clearState(); alert('已清除儲存'); } };

  document.getElementById('btnExport').onclick=()=>{ if(!history.length){ alert('沒有歷史可匯出'); return; } const header=['#','時間','扣牌數','剩餘','Trials','Seed','閒%','莊%','和%'];
    const rows=history.map((h,i)=>[i+1,h.time,h.rem,h.left,h.trials,h.seed,h.p.toFixed(2),h.b.toFixed(2),h.t.toFixed(2)].join(',')); const csv=[header.join(','),...rows].join('\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='baccarat_history.csv'; a.click(); URL.revokeObjectURL(url); };
  document.getElementById('btnClearHist').onclick=()=>{ if(confirm('清空歷史紀錄？')){ history=[]; saveHist(history); redrawTable(); redrawChart(); } };

  document.getElementById('btnB').onclick=()=> addOutcome('B');
  document.getElementById('btnP').onclick=()=> addOutcome('P');
  document.getElementById('btnT').onclick=()=> addOutcome('T');
  document.getElementById('btnUndo').onclick=()=> undoOutcome();
  document.getElementById('btnClearRoads').onclick=()=>{ if(confirm('清空全部路圖？')) clearOutcomes(); };
  document.getElementById('btnApplyGrid').onclick=()=> rebuildRoads();

  // 初始
  let shoeInitDone = !loadState(); if(shoeInitDone){ refreshCounts(); }
  redrawTable(); redrawChart(); rebuildRoads();

  // SW v4.4
  if('serviceWorker' in navigator){ window.addEventListener('load', ()=>{ navigator.serviceWorker.register('./sw_v44.js'); }); }
  </script>
</body>
</html>
