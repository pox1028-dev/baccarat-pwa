<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#111827"/>
  <title>百家樂勝率計算器 v4.2（含下三路圖・單檔版）</title>
  <link rel="manifest" href="./manifest.webmanifest">
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --accent:#22c55e; --text:#e5e7eb; --danger:#ef4444; }
    *{ box-sizing:border-box; }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Noto Sans TC','PingFang TC','Hiragino Sans','Microsoft JhengHei',system-ui,sans-serif; }
    header{ padding:16px 16px 8px; text-align:center; }
    h1{ margin:0; font-size:20px; }
    .wrap{ max-width:980px; margin:0 auto; padding:10px; }
    .card{ background:var(--card); border:1px solid #1f2937; border-radius:12px; padding:14px; margin:10px; box-shadow: 0 6px 24px rgba(0,0,0,.25); }
    label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
    input[type=text], input[type=number]{ width:100%; padding:12px; border-radius:10px; border:1px solid #334155; background:#0b1220; color:var(--text); outline:none; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; } .row>*{ flex:1 1 180px; }
    button{ background:#1f2937; color:var(--text); border:1px solid #374151; padding:10px 12px; border-radius:10px; cursor:pointer; }
    button.primary{ background:var(--accent); border-color:#16a34a; color:#06220f; font-weight:600; }
    button.danger{ background:#311316; border-color:#7f1d1d; color:#fecaca; }
    small{ color:var(--muted); }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; }
    .stat{ flex:1 1 140px; background:#0b1220; border:1px solid #334155; border-radius:12px; padding:12px; text-align:center; }
    .stat h3{ margin:0; font-size:14px; color:#94a3b8; } .stat .v{ font-size:24px; font-weight:700; margin-top:6px; }
    .chips{ margin-top:6px; } .chip{ display:inline-flex; align-items:center; gap:6px; border:1px dashed #334155; border-radius:999px; padding:5px 8px; margin:4px 6px 0 0; }
    .x{ cursor:pointer; color:#fca5a5; font-weight:700; }
    .hint{ font-size:12px; color:#94a3b8; margin-top:4px; }

    /* 下三路圖樣式 */
    .roadsWrap{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
    .roadBox{ background:#0b1220; border:1px solid #334155; border-radius:12px; padding:10px; }
    .roadTitle{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; color:#94a3b8; font-size:13px; }
    .roadGrid{ display:grid; grid-template-rows: repeat(6, 22px); grid-auto-flow: column; gap:2px; overflow-x:auto; padding-bottom:4px; }
    .cell{ width:22px; height:22px; border:1px solid #1f2937; border-radius:50%; }
    .red{ background:#ef4444; } .blue{ background:#3b82f6; } .green{ background:transparent; border-color:#065f46; box-shadow: inset 0 0 0 2px #10b981; border-radius:4px; }

    .footer{ text-align:center; color:#94a3b8; padding:16px 0 30px; font-size:12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header><h1>百家樂勝率計算器 v4.2（含下三路圖・單檔版）</h1></header>
  <div class="wrap">
    <!-- 主要表單（保留簡化，與原v42相容） -->
    <div class="card">
      <div class="row">
        <div><label>副數 (預設 8)</label><input id="decks" type="number" min="1" max="16" value="8"></div>
        <div><label>模擬局數 Trials（建議 20000~60000）</label><input id="trials" type="number" min="1000" step="1000" value="30000"></div>
        <div><label>固定亂數種子（可空白）</label><input id="seed" type="number" placeholder="如 20250831"></div>
      </div>
      <div style="margin-top:10px;">
        <label>輸入已開牌（連續輸入即可；T 或 10 都代表 10）</label>
        <input id="cards" type="text" placeholder="例如：AK103QQ7 → A K 10 3 Q Q 7">
        <div class="row" style="margin-top:10px;">
          <button id="btnAdd">加入已開牌</button>
          <button id="btnCompute" class="primary">計算下局勝率</button>
          <button id="btnReset" class="danger">重設新牌靴</button>
        </div>
        <div class="hint">提示：每局把新開出的牌補進再按「計算」。</div>
      </div>
    </div>

    <div class="card">
      <label>結果</label>
      <div class="stats">
        <div class="stat"><h3>莊 (Banker)</h3><div id="bank" class="v">-</div></div>
        <div class="stat"><h3>閒 (Player)</h3><div id="play" class="v">-</div></div>
        <div class="stat"><h3>和 (Tie)</h3><div id="tie" class="v">-</div></div>
        <div class="stat"><h3>模擬局數</h3><div id="n" class="v">-</div></div>
      </div>
    </div>

    <!-- 新增：大路紀錄 + 下三路圖 -->
    <div class="card">
      <div class="roadTitle"><b>大路紀錄</b><small>按下方按鈕依實際結果記錄；和（Tie）以綠框標註在格子角落。</small></div>
      <div class="row" style="gap:8px; align-items:center;">
        <button id="btnLogB">＋ 記錄【莊】</button>
        <button id="btnLogP">＋ 記錄【閒】</button>
        <button id="btnLogT">＋ 記錄【和】</button>
        <button id="btnClearRoads" class="danger">清空路圖</button>
      </div>
      <div style="margin:10px 0; color:#94a3b8; font-size:12px;">（說明：大路只記 B/P；和會疊在當前格。下三路依大路演算法推導紅／藍）</div>
      <div class="roadsWrap">
        <div class="roadBox">
          <div class="roadTitle"><b>大眼仔 (Big Eye Boy)</b><small id="lenBE"></small></div>
          <div id="gridBE" class="roadGrid"></div>
        </div>
        <div class="roadBox">
          <div class="roadTitle"><b>小路 (Small Road)</b><small id="lenSR"></small></div>
          <div id="gridSR" class="roadGrid"></div>
        </div>
        <div class="roadBox">
          <div class="roadTitle"><b>曱甴路 (Cockroach)</b><small id="lenCP"></small></div>
          <div id="gridCP" class="roadGrid"></div>
        </div>
      </div>
    </div>

    <div class="footer">此頁為 v4.2 單檔版，僅新增「下三路圖」視覺；演算法為常見實作的簡化版。</div>
  </div>

  <script>
  // ====== v42 Monte Carlo（簡化保留界面；完整邏輯依你原版） ======
  const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
  const VAL={'A':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':0,'J':0,'Q':0,'K':0};
  const VALUES_LIST=RANKS.map(r=>VAL[r]);
  function newShoe(numDecks=8){ const shoe={}; for(const r of RANKS) shoe[r]=4*numDecks; return shoe; }
  function shoeCounts(shoe){ return RANKS.map(r=>shoe[r]); }
  function parseCards(s){ s=(s||'').toUpperCase().replace(/,/g,'').replace(/\s+/g,''); const out=[];
    for(let i=0;i<s.length;i++){ const ch=s[i]; if(ch==='1'&&s[i+1]==='0'){out.push('10');i++;} else if(ch==='T'){out.push('10');} else if('A23456789JQK'.includes(ch)){out.push(ch);} } return out; }
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;};}
  function weightedDraw(counts,total,rand){let r=Math.floor(rand()*total)+1,c=0;for(let i=0;i<counts.length;i++){c+=counts[i];if(r<=c)return i;}return counts.length-1;}
  function simulateOneRound(counts,rand){const lc=counts.slice();let tot=lc.reduce((a,b)=>a+b,0);if(tot<4)return null;function draw(){const i=weightedDraw(lc,tot,rand);lc[i]-=1;tot-=1;return i;}
    const p=[draw(),draw()],b=[draw(),draw()]; let pt=(VALUES_LIST[p[0]]+VALUES_LIST[p[1]])%10,bt=(VALUES_LIST[b[0]]+VALUES_LIST[b[1]])%10;
    if(!(pt===8||pt===9||bt===8||bt===9)){let pv=null;if(pt<=5){p.push(draw());pv=VALUES_LIST[p[p.length-1]];pt=(pt+pv)%10;
      if(bt<=2){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===3&&pv!==8){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===4&&(2<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===5&&(4<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
      else if(bt===6&&(6<=pv&&pv<=7)){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;}
    }else{ if(bt<=5){b.push(draw());bt=(bt+VALUES_LIST[b[b.length-1]])%10;} } }
    if(pt>bt)return 0; if(bt>pt)return 1; return 2; }
  function monteCarlo(counts,trials=30000,seed=null){const wins=[0,0,0],rand=seed?mulberry32(Number(seed)>>>0):Math.random;let valid=0;
    for(let i=0;i<trials;i++){const r=simulateOneRound(counts,rand);if(r===null)break;wins[r]++;valid++;} if(valid===0)return{p:[0,0,0],n:0}; return{p:[wins[0]/valid,wins[1]/valid,wins[2]/valid],n:valid};}

  // ====== 下三路（簡化規則） ======
  const bigRoad=[]; // {result:'B'|'P', ties:0}
  const gridBE=document.getElementById('gridBE'), gridSR=document.getElementById('gridSR'), gridCP=document.getElementById('gridCP');

  document.getElementById('btnLogB').onclick=()=>{ pushBigRoad('B'); };
  document.getElementById('btnLogP').onclick=()=>{ pushBigRoad('P'); };
  document.getElementById('btnLogT').onclick=()=>{ pushTie(); };
  document.getElementById('btnClearRoads').onclick=()=>{ bigRoad.length=0; renderAll(); };

  function pushBigRoad(bp){ bigRoad.push({result:bp, ties:0}); renderAll(); }
  function pushTie(){ if(bigRoad.length===0){ bigRoad.push({result:'P', ties:1}); } else { bigRoad[bigRoad.length-1].ties+=1; } renderAll(); }

  function toColumnsFromBigRoad(){
    const cols=[]; let cur=[];
    for(const r of bigRoad){
      if(cur.length===0 || cur[0].result===r.result){ cur.push(r); }
      else{ cols.push(cur); cur=[r]; }
    }
    if(cur.length) cols.push(cur);
    return cols;
  }

  function deriveDownRoads(){
    const cols=toColumnsFromBigRoad();
    const bigEye=[], smallR=[], cockP=[];
    function makeRule(startRow, out){
      for(let c=1;c<cols.length;c++){
        const refIdx=c-startRow; if(refIdx<0) continue;
        const leftPrev=cols[c-1]?.length||0;
        const refPrev=cols[refIdx]?.length||0;
        out.push(leftPrev===refPrev?'R':'B');
      }
    }
    makeRule(1,bigEye); // 大眼仔第2列起
    makeRule(2,smallR); // 小路第3列起
    makeRule(3,cockP);  // 曱甴第4列起
    return {bigEye, smallR, cockP};
  }

  function renderGrid(container, arr){
    container.innerHTML='';
    arr.forEach(code=>{
      const cell=document.createElement('div');
      cell.className='cell '+(code==='R'?'red':'blue');
      container.appendChild(cell);
    });
  }
  function renderAll(){
    const {bigEye, smallR, cockP}=deriveDownRoads();
    renderGrid(gridBE, bigEye); renderGrid(gridSR, smallR); renderGrid(gridCP, cockP);
    document.getElementById('lenBE').textContent='共 '+bigEye.length+' 點';
    document.getElementById('lenSR').textContent='共 '+smallR.length+' 點';
    document.getElementById('lenCP').textContent='共 '+cockP.length+' 點';
  }
  renderAll();

  // ====== （示意）保留v42核心按鈕掛載，可與你現有邏輯對接 ======
  const decksEl=document.getElementById('decks'), trialsEl=document.getElementById('trials'), seedEl=document.getElementById('seed'), cardsEl=document.getElementById('cards');
  document.getElementById('btnAdd').onclick=()=>{/* 依你的 v42 扣牌邏輯接上 */};
  document.getElementById('btnReset').onclick=()=>{/* 依你的 v42 重設邏輯接上 */};
  document.getElementById('btnCompute').onclick=()=>{/* 依你的 v42 計算邏輯接上；可在結果出來後，按實局結果 pushBigRoad('B'/'P'/'T') */};
  </script>
</body>
</html>
